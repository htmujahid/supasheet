-- Custom types
create type public.app_permission as enum ('accounts', 'resources', 'user_roles', 'role_permissions');
create type public.app_role as enum ('admin', 'user');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  account_id   uuid references public.accounts on delete cascade not null,
  role      app_role not null,
  unique (account_id, role)
);

alter table public.user_roles enable row level security;

revoke all on table public.user_roles from authenticated, service_role;

grant select, insert, update, delete on table public.user_roles to authenticated, service_role;

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);

alter table public.role_permissions enable row level security;

revoke all on table public.role_permissions from authenticated, service_role;

grant select, insert, update, delete on table public.role_permissions to authenticated, service_role;

create or replace function public.has_permission(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  select role into user_role from public.user_roles where account_id = auth.uid();

  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

grant execute on function public.has_permission(app_permission) to authenticated, service_role;

create or replace function public.has_role(
  requested_role app_role
)
returns boolean as $$
declare
  user_role public.app_role;
begin
  select role into user_role from public.user_roles where account_id = auth.uid();

  return user_role = requested_role;
end;
$$ language plpgsql stable security definer set search_path = '';

create index on public.user_roles using btree (account_id);

grant execute on function public.has_role(app_role) to authenticated, service_role;

create policy "User can view their own role" on public.user_roles for select using (
  (select auth.uid()) = account_id
);

create policy "User can view their own role permissions" on public.role_permissions for select using (
  (select (public.has_role(role)))
);

create policy "Enable read access for authorized users"
on "public"."resources"
as PERMISSIVE
for SELECT
to authenticated
using (
  (select (public.has_permission(id::app_permission)))
);

insert into public.role_permissions (role, permission) values ('admin', 'accounts');
insert into public.role_permissions (role, permission) values ('user', 'accounts');

create or replace function public.new_account_created_setup() 
returns trigger 
language plpgsql 
as $$
begin
  insert into public.user_roles (account_id, role) values (new.id, 'user');
  return new;
end;
$$;

-- trigger the function every time a user is created
create trigger on_account_created
    after insert
    on public.accounts
    for each row
execute procedure public.new_account_created_setup();
